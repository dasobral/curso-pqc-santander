<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ML-KEM - Ejemplos Pr√°cticos - Curso de Criptograf√≠a Post-Cu√°ntica</title>
    <link rel="stylesheet" href="../css/styles.css">
    <link rel="stylesheet" href="../css/prism.css">
</head>
<body>
    <header>
        <h1>Curso de Criptograf√≠a Post-Cu√°ntica</h1>
        <p>Un enfoque introductorio a la seguridad en la era cu√°ntica</p>
        <div class="search-container">
            <input type="text" id="searchInput" placeholder="Buscar en el curso...">
            <button onclick="search()">üîç</button>
        </div>
        <nav>
            <ul>
                <li><a href="../index.html">Inicio</a></li>
                <li><a href="../programa.html">Programa</a></li>
                <li><a href="../temas/tema1/index.html">Temas</a></li>
                <li><a href="index.html" class="active">Ejemplos Pr√°cticos</a></li>
                <li><a href="../guias/index.html">Gu√≠as de Laboratorio</a></li>
                <li><a href="../recursos/index.html">Recursos</a></li>
            </ul>
        </nav>
    </header>

    <div class="breadcrumbs">
        <a href="../index.html">Inicio</a> &gt; <a href="index.html">Ejemplos Pr√°cticos</a> &gt; ML-KEM
    </div>

    <main>
        <h1>ML-KEM: Mecanismo de Encapsulamiento de Claves basado en Ret√≠culos</h1>
        
        <div class="ejemplo-header">
            <div class="ejemplo-icon large">üîê</div>
            <div class="ejemplo-meta">
                <p class="ejemplo-tema">Tema relacionado: <a href="../temas/tema4/index.html">Tema 4: Estandarizaci√≥n de Criptograf√≠a Post-Cu√°ntica</a></p>
                <p class="ejemplo-guia">Gu√≠a de laboratorio: <a href="../guias/ml_kem.html">Gu√≠a de ML-KEM</a></p>
            </div>
        </div>

        <section class="ejemplo-intro">
            <h2>Introducci√≥n</h2>
            <p>
                ML-KEM (Module-Lattice Key Encapsulation Mechanism), anteriormente conocido como CRYSTALS-Kyber, es un mecanismo de encapsulamiento de claves basado en problemas de ret√≠culos modulares. Ha sido seleccionado por el NIST como el est√°ndar FIPS 203 para el intercambio de claves post-cu√°ntico.
            </p>
            <p>
                ML-KEM proporciona un m√©todo seguro para que dos partes establezcan una clave compartida que puede utilizarse posteriormente para cifrado sim√©trico. A diferencia de los algoritmos de intercambio de claves tradicionales como Diffie-Hellman o RSA, ML-KEM est√° dise√±ado para resistir ataques de ordenadores cu√°nticos.
            </p>
            <p>
                En este ejemplo, exploraremos c√≥mo funciona ML-KEM y demostraremos sus operaciones b√°sicas: generaci√≥n de claves, encapsulamiento y desencapsulamiento.
            </p>
        </section>

        <section class="ejemplo-teoria">
            <h2>Fundamento Te√≥rico</h2>
            
            <h3>Problemas de Ret√≠culos</h3>
            <p>
                ML-KEM basa su seguridad en la dificultad de resolver ciertos problemas relacionados con ret√≠culos, espec√≠ficamente el problema de Learning With Errors (LWE) en su variante modular:
            </p>
            <ul>
                <li><strong>Module-LWE (MLWE):</strong> Una generalizaci√≥n de Ring-LWE que proporciona un mejor equilibrio entre seguridad y eficiencia.</li>
                <li><strong>Problema Computacional:</strong> Dado un conjunto de muestras (a, b = a¬∑s + e), donde a es aleatorio, s es secreto y e es un peque√±o error, encontrar s es computacionalmente dif√≠cil.</li>
            </ul>
            
            <h3>Estructura de ML-KEM</h3>
            <p>
                ML-KEM es un mecanismo de encapsulamiento de claves (KEM) que consta de tres algoritmos principales:
            </p>
            <ol>
                <li><strong>KeyGen:</strong> Genera un par de claves p√∫blica/privada.</li>
                <li><strong>Encaps:</strong> Utiliza la clave p√∫blica para encapsular (cifrar) una clave sim√©trica compartida.</li>
                <li><strong>Decaps:</strong> Utiliza la clave privada para desencapsular (descifrar) la clave sim√©trica compartida.</li>
            </ol>
            
            <h3>Par√°metros de ML-KEM</h3>
            <p>
                ML-KEM viene en tres variantes que ofrecen diferentes niveles de seguridad:
            </p>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Variante</th>
                        <th>Nivel de Seguridad</th>
                        <th>Tama√±o de Clave P√∫blica</th>
                        <th>Tama√±o de Clave Privada</th>
                        <th>Tama√±o de Cifrado</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>ML-KEM-512</td>
                        <td>Nivel 1 (AES-128)</td>
                        <td>800 bytes</td>
                        <td>1,632 bytes</td>
                        <td>768 bytes</td>
                    </tr>
                    <tr>
                        <td>ML-KEM-768</td>
                        <td>Nivel 3 (AES-192)</td>
                        <td>1,184 bytes</td>
                        <td>2,400 bytes</td>
                        <td>1,088 bytes</td>
                    </tr>
                    <tr>
                        <td>ML-KEM-1024</td>
                        <td>Nivel 5 (AES-256)</td>
                        <td>1,568 bytes</td>
                        <td>3,168 bytes</td>
                        <td>1,568 bytes</td>
                    </tr>
                </tbody>
            </table>
            
            <h3>Operaciones Matem√°ticas</h3>
            <p>
                ML-KEM utiliza varias operaciones matem√°ticas espec√≠ficas:
            </p>
            <ul>
                <li><strong>Polinomios:</strong> Operaciones en el anillo R = Z_q[X]/(X^n + 1), donde n = 256 y q = 3329.</li>
                <li><strong>M√≥dulos:</strong> Vectores y matrices de polinomios que permiten ajustar el nivel de seguridad.</li>
                <li><strong>NTT (Transformada N√∫mero-Te√≥rica):</strong> Utilizada para multiplicaci√≥n eficiente de polinomios.</li>
                <li><strong>Compresi√≥n y Descompresi√≥n:</strong> T√©cnicas para reducir el tama√±o de las claves y cifrados.</li>
                <li><strong>Funciones Hash:</strong> SHA3-256, SHA3-512 y SHAKE-128/256 para derivaci√≥n de claves y aleatorizaci√≥n.</li>
            </ul>
        </section>

        <section class="ejemplo-simulacion">
            <h2>Simulaci√≥n Interactiva</h2>
            
            <div class="simulacion-container">
                <div class="simulacion-controls">
                    <div class="control-group">
                        <label for="securityLevel">Nivel de Seguridad:</label>
                        <select id="securityLevel">
                            <option value="512">ML-KEM-512 (Nivel 1)</option>
                            <option value="768" selected>ML-KEM-768 (Nivel 3)</option>
                            <option value="1024">ML-KEM-1024 (Nivel 5)</option>
                        </select>
                    </div>
                    
                    <button id="btnGenerateKeys" class="btn">Generar Claves</button>
                    <button id="btnEncaps" class="btn" disabled>Encapsular Clave</button>
                    <button id="btnDecaps" class="btn" disabled>Desencapsular Clave</button>
                    <button id="btnReset" class="btn btn-outline">Reiniciar</button>
                </div>
                
                <div class="simulacion-output">
                    <h3>Resultados</h3>
                    <div id="outputPasos" class="output-pasos">
                        <p>Seleccione un nivel de seguridad y haga clic en "Generar Claves" para comenzar.</p>
                    </div>
                    
                    <div class="output-keys">
                        <div class="key-container">
                            <h4>Clave P√∫blica</h4>
                            <pre id="publicKey" class="key-display">-</pre>
                        </div>
                        <div class="key-container">
                            <h4>Clave Privada</h4>
                            <pre id="privateKey" class="key-display">-</pre>
                        </div>
                        <div class="key-container">
                            <h4>Clave Compartida</h4>
                            <pre id="sharedKey" class="key-display">-</pre>
                        </div>
                        <div class="key-container">
                            <h4>Cifrado</h4>
                            <pre id="ciphertext" class="key-display">-</pre>
                        </div>
                    </div>
                </div>
                
                <div class="simulacion-visualization">
                    <h3>Visualizaci√≥n</h3>
                    <div id="visualization" class="visualization-container">
                        <!-- La visualizaci√≥n se generar√° din√°micamente con JavaScript -->
                    </div>
                </div>
            </div>
        </section>

        <section class="ejemplo-codigo">
            <h2>Implementaci√≥n</h2>
            
            <p>
                A continuaci√≥n se muestra una implementaci√≥n simplificada de ML-KEM en Python. 
                Esta implementaci√≥n es para fines educativos y omite muchos detalles t√©cnicos del algoritmo real.
            </p>
            
            <pre><code class="language-python">import numpy as np
import hashlib
import secrets

# Par√°metros simplificados para ML-KEM
class MLKEMParams:
    def __init__(self, k, eta1, eta2, du, dv):
        self.n = 256  # Grado del polinomio
        self.q = 3329  # M√≥dulo
        self.k = k  # Dimensi√≥n del m√≥dulo
        self.eta1 = eta1  # Par√°metro de distribuci√≥n de ruido
        self.eta2 = eta2  # Par√°metro de distribuci√≥n de ruido
        self.du = du  # Par√°metro de compresi√≥n
        self.dv = dv  # Par√°metro de compresi√≥n

# Definici√≥n de par√°metros para diferentes niveles de seguridad
def get_params(security_level):
    if security_level == 512:  # Nivel 1
        return MLKEMParams(k=2, eta1=3, eta2=2, du=10, dv=4)
    elif security_level == 768:  # Nivel 3
        return MLKEMParams(k=3, eta1=2, eta2=2, du=10, dv=4)
    elif security_level == 1024:  # Nivel 5
        return MLKEMParams(k=4, eta1=2, eta2=2, du=11, dv=5)
    else:
        raise ValueError("Nivel de seguridad no v√°lido")

# Funciones auxiliares simplificadas
def sample_poly(n, q, eta):
    """Genera un polinomio con coeficientes peque√±os."""
    return np.array([secrets.randbelow(2*eta+1) - eta for _ in range(n)]) % q

def sample_matrix(k, n, q):
    """Genera una matriz de polinomios aleatorios."""
    return np.array([[secrets.randbelow(q) for _ in range(n)] for _ in range(k)])

def compress(x, d, q):
    """Comprime un valor x a d bits."""
    return round((2**d / q) * x) % (2**d)

def decompress(x, d, q):
    """Descomprime un valor x de d bits."""
    return round((q / 2**d) * x) % q

def hash_function(data, length):
    """Funci√≥n hash simplificada basada en SHA3."""
    h = hashlib.sha3_256(data).digest()
    if length > len(h):
        h += hashlib.sha3_256(h).digest()
    return h[:length]

# Implementaci√≥n simplificada de ML-KEM
class MLKEM:
    def __init__(self, security_level=768):
        self.params = get_params(security_level)
        self.n = self.params.n
        self.q = self.params.q
        self.k = self.params.k
    
    def keygen(self):
        """Genera un par de claves p√∫blica/privada."""
        # Generar semilla aleatoria
        d = secrets.token_bytes(32)
        
        # Generar matriz A (en una implementaci√≥n real, esto se har√≠a de forma determinista)
        A = sample_matrix(self.k, self.n, self.q)
        
        # Generar vector secreto s
        s = np.array([sample_poly(self.n, self.q, self.params.eta1) for _ in range(self.k)])
        
        # Generar vector de error e
        e = np.array([sample_poly(self.n, self.q, self.params.eta1) for _ in range(self.k)])
        
        # Calcular t = A¬∑s + e
        t = np.zeros((self.k, self.n), dtype=int)
        for i in range(self.k):
            for j in range(self.k):
                # En una implementaci√≥n real, esto ser√≠a una multiplicaci√≥n de polinomios
                t[i] = (t[i] + np.convolve(A[i, j], s[j], mode='same')) % self.q
            t[i] = (t[i] + e[i]) % self.q
        
        # Clave p√∫blica: (t, d)
        public_key = (t, d)
        
        # Clave privada: (s, t, d)
        private_key = (s, t, d)
        
        return public_key, private_key
    
    def encaps(self, public_key):
        """Encapsula una clave compartida usando la clave p√∫blica."""
        t, d = public_key
        
        # Generar mensaje aleatorio m
        m = secrets.token_bytes(32)
        
        # Derivar ruido y semilla a partir de m y d
        seed = hash_function(m + bytes(d), 32)
        
        # Generar matriz A (en una implementaci√≥n real, esto se har√≠a de forma determinista)
        A = sample_matrix(self.k, self.n, self.q)
        
        # Generar vector r
        r = np.array([sample_poly(self.n, self.q, self.params.eta1) for _ in range(self.k)])
        
        # Generar vector de error e1
        e1 = np.array([sample_poly(self.n, self.q, self.params.eta2) for _ in range(self.k)])
        
        # Generar error e2
        e2 = sample_poly(self.n, self.q, self.params.eta2)
        
        # Calcular u = A^T¬∑r + e1
        u = np.zeros((self.k, self.n), dtype=int)
        for i in range(self.k):
            for j in range(self.k):
                # En una implementaci√≥n real, esto ser√≠a una multiplicaci√≥n de polinomios
                u[i] = (u[i] + np.convolve(A[j, i], r[j], mode='same')) % self.q
            u[i] = (u[i] + e1[i]) % self.q
        
        # Calcular v = t^T¬∑r + e2 + ‚åàq/2‚åã¬∑m
        v = np.zeros(self.n, dtype=int)
        for i in range(self.k):
            # En una implementaci√≥n real, esto ser√≠a una multiplicaci√≥n de polinomios
            v = (v + np.convolve(t[i], r[i], mode='same')) % self.q
        
        # A√±adir error y mensaje
        v = (v + e2) % self.q
        
        # Codificar mensaje en el dominio de la se√±al
        m_bits = ''.join(format(b, '08b') for b in m)
        for i in range(min(self.n, len(m_bits))):
            if i < len(m_bits) and m_bits[i] == '1':
                v[i] = (v[i] + (self.q // 2)) % self.q
        
        # Comprimir u y v
        u_compressed = np.array([[compress(u[i][j], self.params.du, self.q) 
                                 for j in range(self.n)] for i in range(self.k)])
        v_compressed = np.array([compress(v[j], self.params.dv, self.q) 
                                for j in range(self.n)])
        
        # Cifrado: (u_compressed, v_compressed)
        ciphertext = (u_compressed, v_compressed)
        
        # Derivar clave compartida
        shared_key = hash_function(m + bytes(ciphertext), 32)
        
        return ciphertext, shared_key
    
    def decaps(self, private_key, ciphertext):
        """Desencapsula la clave compartida usando la clave privada y el cifrado."""
        s, t, d = private_key
        u_compressed, v_compressed = ciphertext
        
        # Descomprimir u y v
        u = np.array([[decompress(u_compressed[i][j], self.params.du, self.q) 
                      for j in range(self.n)] for i in range(self.k)])
        v = np.array([decompress(v_compressed[j], self.params.dv, self.q) 
                     for j in range(self.n)])
        
        # Calcular m' = v - s^T¬∑u
        m_prime = np.copy(v)
        for i in range(self.k):
            # En una implementaci√≥n real, esto ser√≠a una multiplicaci√≥n de polinomios
            m_prime = (m_prime - np.convolve(s[i], u[i], mode='same')[:self.n]) % self.q
        
        # Decodificar mensaje
        m = bytearray(32)
        for i in range(min(self.n, 256)):  # 256 bits = 32 bytes
            bit_pos = i // 8
            bit_offset = i % 8
            # Comprobar si el coeficiente est√° m√°s cerca de q/2 o 0
            if abs(m_prime[i] - (self.q // 2)) < abs(m_prime[i]):
                m[bit_pos] |= (1 << bit_offset)
        
        # Verificar la validez del mensaje desencapsulado
        seed = hash_function(bytes(m) + bytes(d), 32)
        
        # En una implementaci√≥n real, se recalcular√≠a el cifrado y se verificar√≠a
        # que coincide con el recibido
        
        # Derivar clave compartida
        shared_key = hash_function(bytes(m) + bytes(ciphertext), 32)
        
        return shared_key

# Ejemplo de uso
def main():
    # Crear instancia de ML-KEM con nivel de seguridad 3
    mlkem = MLKEM(security_level=768)
    
    # Generar par de claves
    public_key, private_key = mlkem.keygen()
    print("Claves generadas")
    
    # Encapsular clave compartida
    ciphertext, shared_key_encaps = mlkem.encaps(public_key)
    print("Clave encapsulada")
    
    # Desencapsular clave compartida
    shared_key_decaps = mlkem.decaps(private_key, ciphertext)
    print("Clave desencapsulada")
    
    # Verificar que las claves compartidas coinciden
    if shared_key_encaps == shared_key_decaps:
        print("√âxito: Las claves compartidas coinciden")
    else:
        print("Error: Las claves compartidas no coinciden")

if __name__ == "__main__":
    main()</code></pre>
            
            <p>
                Esta implementaci√≥n es una simplificaci√≥n significativa del algoritmo ML-KEM real. En la pr√°ctica, ML-KEM utiliza:
            </p>
            <ul>
                <li>Transformada N√∫mero-Te√≥rica (NTT) para multiplicaci√≥n eficiente de polinomios</li>
                <li>Generaci√≥n determinista de la matriz A a partir de una semilla</li>
                <li>T√©cnicas de muestreo eficientes para distribuciones binomiales</li>
                <li>Codificaci√≥n y decodificaci√≥n optimizadas</li>
                <li>Medidas adicionales contra ataques de canal lateral</li>
            </ul>
            <p>
                Para implementaciones completas y seguras, se recomienda utilizar bibliotecas criptogr√°ficas establecidas como liboqs o pqcrypto.
            </p>
        </section>

        <section class="ejemplo-impacto">
            <h2>Ventajas y Consideraciones</h2>
            
            <div class="impacto-grid">
                <div class="impacto-item">
                    <h3>Ventajas</h3>
                    <ul>
                        <li><strong>Seguridad Post-Cu√°ntica:</strong> Resistente a ataques de ordenadores cu√°nticos, incluido el algoritmo de Shor.</li>
                        <li><strong>Eficiencia:</strong> Operaciones relativamente r√°pidas y tama√±os de clave/cifrado moderados.</li>
                        <li><strong>Flexibilidad:</strong> Diferentes niveles de seguridad para distintas necesidades.</li>
                        <li><strong>Estandarizaci√≥n:</strong> Seleccionado como est√°ndar FIPS 203 por el NIST.</li>
                        <li><strong>An√°lisis Extenso:</strong> Ha sido sometido a un riguroso an√°lisis criptogr√°fico durante el proceso de selecci√≥n del NIST.</li>
                    </ul>
                </div>
                
                <div class="impacto-item">
                    <h3>Consideraciones</h3>
                    <ul>
                        <li><strong>Tama√±o de Claves:</strong> Las claves son m√°s grandes que en criptograf√≠a de curva el√≠ptica (aunque m√°s peque√±as que otros esquemas post-cu√°nticos).</li>
                        <li><strong>Novedad:</strong> Menos probado en el tiempo que algoritmos tradicionales como RSA o ECDH.</li>
                        <li><strong>Implementaci√≥n:</strong> Requiere cuidado para evitar vulnerabilidades de implementaci√≥n y ataques de canal lateral.</li>
                        <li><strong>Integraci√≥n:</strong> La migraci√≥n a ML-KEM en sistemas existentes puede requerir modificaciones significativas.</li>
                    </ul>
                </div>
            </div>
            
            <h3>Comparaci√≥n con Otros Mecanismos de Intercambio de Claves</h3>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Caracter√≠stica</th>
                        <th>ML-KEM</th>
                        <th>RSA</th>
                        <th>ECDH</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Seguridad Post-Cu√°ntica</td>
                        <td>S√≠</td>
                        <td>No</td>
                        <td>No</td>
                    </tr>
                    <tr>
                        <td>Tama√±o de Clave P√∫blica (Nivel 128 bits)</td>
                        <td>~800-1,568 bytes</td>
                        <td>~256-384 bytes</td>
                        <td>~32-64 bytes</td>
                    </tr>
                    <tr>
                        <td>Tama√±o de Cifrado/Intercambio</td>
                        <td>~768-1,568 bytes</td>
                        <td>~256-384 bytes</td>
                        <td>~32-64 bytes</td>
                    </tr>
                    <tr>
                        <td>Velocidad de Operaci√≥n</td>
                        <td>R√°pida</td>
                        <td>Lenta</td>
                        <td>Muy r√°pida</td>
                    </tr>
                    <tr>
                        <td>Base Matem√°tica</td>
                        <td>Ret√≠culos Modulares</td>
                        <td>Factorizaci√≥n</td>
                        <td>Logaritmo Discreto</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section class="ejemplo-aplicaciones">
            <h2>Aplicaciones Pr√°cticas</h2>
            
            <div class="aplicaciones-grid">
                <div class="aplicacion-item">
                    <h3>TLS/SSL</h3>
                    <p>
                        ML-KEM puede integrarse en protocolos TLS para establecer conexiones seguras post-cu√°nticas. 
                        Existen implementaciones experimentales en OpenSSL y BoringSSL que permiten el uso de ML-KEM 
                        en el handshake TLS, ya sea en modo h√≠brido (combinado con ECDHE) o como √∫nico mecanismo.
                    </p>
                </div>
                
                <div class="aplicacion-item">
                    <h3>VPN</h3>
                    <p>
                        Las redes privadas virtuales pueden utilizar ML-KEM para el establecimiento de claves, 
                        proporcionando seguridad post-cu√°ntica para las comunicaciones empresariales. Proyectos como 
                        OpenVPN y WireGuard est√°n explorando la integraci√≥n de algoritmos post-cu√°nticos.
                    </p>
                </div>
                
                <div class="aplicacion-item">
                    <h3>Cifrado de Correo Electr√≥nico</h3>
                    <p>
                        Protocolos como S/MIME y OpenPGP pueden beneficiarse de ML-KEM para el intercambio seguro 
                        de claves de sesi√≥n, permitiendo el cifrado de correos electr√≥nicos resistente a ataques cu√°nticos.
                    </p>
                </div>
                
                <div class="aplicacion-item">
                    <h3>IoT y Dispositivos Embebidos</h3>
                    <p>
                        ML-KEM es relativamente eficiente en t√©rminos de recursos computacionales, lo que lo hace 
                        adecuado para dispositivos con restricciones como sensores IoT y sistemas embebidos que 
                        necesitan seguridad a largo plazo.
                    </p>
                </div>
            </div>
        </section>

        <section class="ejemplo-recursos">
            <h2>Recursos Adicionales</h2>
            
            <ul>
                <li>
                    <a href="https://csrc.nist.gov/pubs/fips/203/ipd" target="_blank">
                        NIST FIPS 203 (Initial Public Draft): Module-Lattice-Based Key-Encapsulation Mechanism Standard
                    </a>
                </li>
                <li>
                    <a href="https://pq-crystals.org/kyber/" target="_blank">
                        Sitio oficial de CRYSTALS-Kyber (ahora ML-KEM)
                    </a>
                </li>
                <li>
                    <a href="https://github.com/open-quantum-safe/liboqs" target="_blank">
                        liboqs: Biblioteca de c√≥digo abierto para criptograf√≠a post-cu√°ntica
                    </a>
                </li>
                <li>
                    <a href="../guias/ml_kem.html">
                        Gu√≠a de Laboratorio: ML-KEM
                    </a>
                </li>
            </ul>
        </section>

        <div class="ejemplo-navegacion">
            <a href="algoritmo_shor.html" class="btn btn-outline">
                <span class="flecha">‚Üê</span> Anterior: Algoritmo de Shor
            </a>
            <a href="ml_dsa.html" class="btn">
                Siguiente: ML-DSA <span class="flecha">‚Üí</span>
            </a>
        </div>
    </main>

    <footer>
        <div class="footer-content">
            <div class="footer-section">
                <h3>Mapa del Sitio</h3>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="../programa.html">Programa</a></li>
                    <li><a href="../temas/tema1/index.html">Temas</a></li>
                    <li><a href="index.html">Ejemplos Pr√°cticos</a></li>
                    <li><a href="../guias/index.html">Gu√≠as de Laboratorio</a></li>
                    <li><a href="../recursos/index.html">Recursos</a></li>
                </ul>
            </div>
            <div class="footer-section">
                <h3>Ejemplos</h3>
                <ul>
                    <li><a href="algoritmo_shor.html">Algoritmo de Shor</a></li>
                    <li><a href="ml_kem.html">ML-KEM</a></li>
                    <li><a href="ml_dsa.html">ML-DSA</a></li>
                    <li><a href="criptografia_hibrida.html">Criptograf√≠a H√≠brida</a></li>
                    <li><a href="qkd_bb84.html">QKD (BB84)</a></li>
                </ul>
            </div>
            <div class="footer-section">
                <h3>Contacto</h3>
                <p>Para consultas sobre el curso, contacte al profesor.</p>
            </div>
        </div>
        <div class="footer-bottom">
            <p>&copy; 2025 Curso de Criptograf√≠a Post-Cu√°ntica</p>
        </div>
    </footer>

    <script src="../js/script.js"></script>
    <script src="../js/prism.js"></script>
    <script>
        // C√≥digo espec√≠fico para la simulaci√≥n de ML-KEM
        document.addEventListener('DOMContentLoaded', function() {
            const btnGenerateKeys = document.getElementById('btnGenerateKeys');
            const btnEncaps = document.getElementById('btnEncaps');
            const btnDecaps = document.getElementById('btnDecaps');
            const btnReset = document.getElementById('btnReset');
            const securityLevel = document.getElementById('securityLevel');
            const outputPasos = document.getElementById('outputPasos');
            const publicKey = document.getElementById('publicKey');
            const privateKey = document.getElementById('privateKey');
            const sharedKey = document.getElementById('sharedKey');
            const ciphertext = document.getElementById('ciphertext');
            const visualization = document.getElementById('visualization');
            
            // Variables para almacenar el estado
            let currentPublicKey = null;
            let currentPrivateKey = null;
            let currentCiphertext = null;
            let currentSharedKey = null;
            
            // Funci√≥n para generar un hash simulado
            function simulateHash(input, length = 32) {
                // Esta es una simulaci√≥n simple, no un hash real
                let hash = '';
                const chars = '0123456789abcdef';
                for (let i = 0; i < length * 2; i++) {
                    hash += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return hash;
            }
            
            // Funci√≥n para generar una representaci√≥n hexadecimal aleatoria
            function generateHexString(length) {
                let result = '';
                const characters = '0123456789abcdef';
                for (let i = 0; i < length; i++) {
                    result += characters.charAt(Math.floor(Math.random() * characters.length));
                }
                return result;
            }
            
            // Funci√≥n para simular la generaci√≥n de claves
            function simulateKeyGen(level) {
                const levelInt = parseInt(level);
                let k, publicKeySize, privateKeySize;
                
                if (levelInt === 512) {
                    k = 2;
                    publicKeySize = 800;
                    privateKeySize = 1632;
                } else if (levelInt === 768) {
                    k = 3;
                    publicKeySize = 1184;
                    privateKeySize = 2400;
                } else { // 1024
                    k = 4;
                    publicKeySize = 1568;
                    privateKeySize = 3168;
                }
                
                // Simular clave p√∫blica (t, d)
                const t = [];
                for (let i = 0; i < k; i++) {
                    t.push(generateHexString(256)); // Simulaci√≥n de polinomios
                }
                const d = generateHexString(64); // Semilla de 32 bytes
                
                // Simular clave privada (s, t, d)
                const s = [];
                for (let i = 0; i < k; i++) {
                    s.push(generateHexString(256)); // Simulaci√≥n de polinomios secretos
                }
                
                return {
                    publicKey: {t, d, size: publicKeySize},
                    privateKey: {s, t, d, size: privateKeySize}
                };
            }
            
            // Funci√≥n para simular el encapsulamiento
            function simulateEncaps(publicKey, level) {
                const levelInt = parseInt(level);
                let k, ciphertextSize;
                
                if (levelInt === 512) {
                    k = 2;
                    ciphertextSize = 768;
                } else if (levelInt === 768) {
                    k = 3;
                    ciphertextSize = 1088;
                } else { // 1024
                    k = 4;
                    ciphertextSize = 1568;
                }
                
                // Simular mensaje aleatorio
                const m = generateHexString(64); // 32 bytes
                
                // Simular cifrado (u, v)
                const u = [];
                for (let i = 0; i < k; i++) {
                    u.push(generateHexString(256)); // Simulaci√≥n de polinomios
                }
                const v = generateHexString(256);
                
                // Simular clave compartida
                const sharedKey = simulateHash(m + JSON.stringify({u, v}));
                
                return {
                    ciphertext: {u, v, size: ciphertextSize},
                    sharedKey
                };
            }
            
            // Funci√≥n para simular el desencapsulamiento
            function simulateDecaps(privateKey, ciphertext) {
                // En una implementaci√≥n real, se recalcular√≠a el cifrado y se verificar√≠a
                // En esta simulaci√≥n, simplemente devolvemos la misma clave compartida
                return currentSharedKey;
            }
            
            // Funci√≥n para visualizar el proceso de ML-KEM
            function visualizeMLKEM(stage, level) {
                visualization.innerHTML = '';
                
                // Crear el contenedor SVG
                const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                svg.setAttribute("width", "100%");
                svg.setAttribute("height", "300");
                svg.setAttribute("viewBox", "0 0 800 300");
                
                // T√≠tulo
                const title = document.createElement("h4");
                
                if (stage === 'keygen') {
                    title.textContent = `Generaci√≥n de Claves ML-KEM-${level}`;
                    
                    // Dibujar el proceso de generaci√≥n de claves
                    // Alicia (generador de claves)
                    const aliceRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    aliceRect.setAttribute("x", "50");
                    aliceRect.setAttribute("y", "50");
                    aliceRect.setAttribute("width", "200");
                    aliceRect.setAttribute("height", "200");
                    aliceRect.setAttribute("rx", "10");
                    aliceRect.setAttribute("ry", "10");
                    aliceRect.setAttribute("fill", "#f0f8ff");
                    aliceRect.setAttribute("stroke", "#3498db");
                    aliceRect.setAttribute("stroke-width", "2");
                    svg.appendChild(aliceRect);
                    
                    // Etiqueta Alicia
                    const aliceText = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    aliceText.setAttribute("x", "150");
                    aliceText.setAttribute("y", "30");
                    aliceText.setAttribute("text-anchor", "middle");
                    aliceText.setAttribute("font-size", "16");
                    aliceText.setAttribute("font-weight", "bold");
                    aliceText.textContent = "Alicia (Generador)";
                    svg.appendChild(aliceText);
                    
                    // Pasos internos
                    const steps = [
                        "1. Generar semilla d",
                        "2. Derivar matriz A",
                        "3. Muestrear s, e",
                        "4. Calcular t = A¬∑s + e"
                    ];
                    
                    for (let i = 0; i < steps.length; i++) {
                        const stepText = document.createElementNS("http://www.w3.org/2000/svg", "text");
                        stepText.setAttribute("x", "60");
                        stepText.setAttribute("y", "80" + i * 30);
                        stepText.setAttribute("font-size", "14");
                        stepText.textContent = steps[i];
                        svg.appendChild(stepText);
                    }
                    
                    // Claves resultantes
                    const pkRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    pkRect.setAttribute("x", "350");
                    pkRect.setAttribute("y", "70");
                    pkRect.setAttribute("width", "150");
                    pkRect.setAttribute("height", "60");
                    pkRect.setAttribute("rx", "5");
                    pkRect.setAttribute("ry", "5");
                    pkRect.setAttribute("fill", "#e8f8f5");
                    pkRect.setAttribute("stroke", "#2ecc71");
                    pkRect.setAttribute("stroke-width", "2");
                    svg.appendChild(pkRect);
                    
                    const pkText = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    pkText.setAttribute("x", "425");
                    pkText.setAttribute("y", "105");
                    pkText.setAttribute("text-anchor", "middle");
                    pkText.setAttribute("font-size", "14");
                    pkText.textContent = "Clave P√∫blica (t, d)";
                    svg.appendChild(pkText);
                    
                    const skRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    skRect.setAttribute("x", "350");
                    skRect.setAttribute("y", "170");
                    skRect.setAttribute("width", "150");
                    skRect.setAttribute("height", "60");
                    skRect.setAttribute("rx", "5");
                    skRect.setAttribute("ry", "5");
                    skRect.setAttribute("fill", "#fef9e7");
                    skRect.setAttribute("stroke", "#f1c40f");
                    skRect.setAttribute("stroke-width", "2");
                    svg.appendChild(skRect);
                    
                    const skText = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    skText.setAttribute("x", "425");
                    skText.setAttribute("y", "205");
                    skText.setAttribute("text-anchor", "middle");
                    skText.setAttribute("font-size", "14");
                    skText.textContent = "Clave Privada (s, t, d)";
                    svg.appendChild(skText);
                    
                    // Flechas
                    const arrow1 = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    arrow1.setAttribute("x1", "250");
                    arrow1.setAttribute("y1", "100");
                    arrow1.setAttribute("x2", "350");
                    arrow1.setAttribute("y2", "100");
                    arrow1.setAttribute("stroke", "#3498db");
                    arrow1.setAttribute("stroke-width", "2");
                    arrow1.setAttribute("marker-end", "url(#arrowhead)");
                    svg.appendChild(arrow1);
                    
                    const arrow2 = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    arrow2.setAttribute("x1", "250");
                    arrow2.setAttribute("y1", "200");
                    arrow2.setAttribute("x2", "350");
                    arrow2.setAttribute("y2", "200");
                    arrow2.setAttribute("stroke", "#3498db");
                    arrow2.setAttribute("stroke-width", "2");
                    arrow2.setAttribute("marker-end", "url(#arrowhead)");
                    svg.appendChild(arrow2);
                    
                } else if (stage === 'encaps') {
                    title.textContent = `Encapsulamiento ML-KEM-${level}`;
                    
                    // Dibujar el proceso de encapsulamiento
                    // Bob (encapsulador)
                    const bobRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    bobRect.setAttribute("x", "350");
                    bobRect.setAttribute("y", "50");
                    bobRect.setAttribute("width", "200");
                    bobRect.setAttribute("height", "200");
                    bobRect.setAttribute("rx", "10");
                    bobRect.setAttribute("ry", "10");
                    bobRect.setAttribute("fill", "#f5eef8");
                    bobRect.setAttribute("stroke", "#9b59b6");
                    bobRect.setAttribute("stroke-width", "2");
                    svg.appendChild(bobRect);
                    
                    // Etiqueta Bob
                    const bobText = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    bobText.setAttribute("x", "450");
                    bobText.setAttribute("y", "30");
                    bobText.setAttribute("text-anchor", "middle");
                    bobText.setAttribute("font-size", "16");
                    bobText.setAttribute("font-weight", "bold");
                    bobText.textContent = "Bob (Encapsulador)";
                    svg.appendChild(bobText);
                    
                    // Clave p√∫blica
                    const pkRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    pkRect.setAttribute("x", "50");
                    pkRect.setAttribute("y", "120");
                    pkRect.setAttribute("width", "150");
                    pkRect.setAttribute("height", "60");
                    pkRect.setAttribute("rx", "5");
                    pkRect.setAttribute("ry", "5");
                    pkRect.setAttribute("fill", "#e8f8f5");
                    pkRect.setAttribute("stroke", "#2ecc71");
                    pkRect.setAttribute("stroke-width", "2");
                    svg.appendChild(pkRect);
                    
                    const pkText = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    pkText.setAttribute("x", "125");
                    pkText.setAttribute("y", "155");
                    pkText.setAttribute("text-anchor", "middle");
                    pkText.setAttribute("font-size", "14");
                    pkText.textContent = "Clave P√∫blica (t, d)";
                    svg.appendChild(pkText);
                    
                    // Pasos internos
                    const steps = [
                        "1. Generar mensaje m",
                        "2. Muestrear r, e1, e2",
                        "3. Calcular u = A^T¬∑r + e1",
                        "4. Calcular v = t^T¬∑r + e2 + m",
                        "5. Derivar clave K"
                    ];
                    
                    for (let i = 0; i < steps.length; i++) {
                        const stepText = document.createElementNS("http://www.w3.org/2000/svg", "text");
                        stepText.setAttribute("x", "360");
                        stepText.setAttribute("y", "80" + i * 30);
                        stepText.setAttribute("font-size", "14");
                        stepText.textContent = steps[i];
                        svg.appendChild(stepText);
                    }
                    
                    // Resultados
                    const ctRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    ctRect.setAttribute("x", "650");
                    ctRect.setAttribute("y", "80");
                    ctRect.setAttribute("width", "150");
                    ctRect.setAttribute("height", "60");
                    ctRect.setAttribute("rx", "5");
                    ctRect.setAttribute("ry", "5");
                    ctRect.setAttribute("fill", "#f8f5ee");
                    ctRect.setAttribute("stroke", "#e67e22");
                    ctRect.setAttribute("stroke-width", "2");
                    svg.appendChild(ctRect);
                    
                    const ctText = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    ctText.setAttribute("x", "725");
                    ctText.setAttribute("y", "115");
                    ctText.setAttribute("text-anchor", "middle");
                    ctText.setAttribute("font-size", "14");
                    ctText.textContent = "Cifrado (u, v)";
                    svg.appendChild(ctText);
                    
                    const keyRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    keyRect.setAttribute("x", "650");
                    keyRect.setAttribute("y", "170");
                    keyRect.setAttribute("width", "150");
                    keyRect.setAttribute("height", "60");
                    keyRect.setAttribute("rx", "5");
                    keyRect.setAttribute("ry", "5");
                    keyRect.setAttribute("fill", "#ebf5fb");
                    keyRect.setAttribute("stroke", "#3498db");
                    keyRect.setAttribute("stroke-width", "2");
                    svg.appendChild(keyRect);
                    
                    const keyText = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    keyText.setAttribute("x", "725");
                    keyText.setAttribute("y", "205");
                    keyText.setAttribute("text-anchor", "middle");
                    keyText.setAttribute("font-size", "14");
                    keyText.textContent = "Clave Compartida K";
                    svg.appendChild(keyText);
                    
                    // Flechas
                    const arrow1 = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    arrow1.setAttribute("x1", "200");
                    arrow1.setAttribute("y1", "150");
                    arrow1.setAttribute("x2", "350");
                    arrow1.setAttribute("y2", "150");
                    arrow1.setAttribute("stroke", "#9b59b6");
                    arrow1.setAttribute("stroke-width", "2");
                    arrow1.setAttribute("marker-end", "url(#arrowhead)");
                    svg.appendChild(arrow1);
                    
                    const arrow2 = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    arrow2.setAttribute("x1", "550");
                    arrow2.setAttribute("y1", "110");
                    arrow2.setAttribute("x2", "650");
                    arrow2.setAttribute("y2", "110");
                    arrow2.setAttribute("stroke", "#9b59b6");
                    arrow2.setAttribute("stroke-width", "2");
                    arrow2.setAttribute("marker-end", "url(#arrowhead)");
                    svg.appendChild(arrow2);
                    
                    const arrow3 = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    arrow3.setAttribute("x1", "550");
                    arrow3.setAttribute("y1", "200");
                    arrow3.setAttribute("x2", "650");
                    arrow3.setAttribute("y2", "200");
                    arrow3.setAttribute("stroke", "#9b59b6");
                    arrow3.setAttribute("stroke-width", "2");
                    arrow3.setAttribute("marker-end", "url(#arrowhead)");
                    svg.appendChild(arrow3);
                    
                } else if (stage === 'decaps') {
                    title.textContent = `Desencapsulamiento ML-KEM-${level}`;
                    
                    // Dibujar el proceso de desencapsulamiento
                    // Alicia (desencapsulador)
                    const aliceRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    aliceRect.setAttribute("x", "350");
                    aliceRect.setAttribute("y", "50");
                    aliceRect.setAttribute("width", "200");
                    aliceRect.setAttribute("height", "200");
                    aliceRect.setAttribute("rx", "10");
                    aliceRect.setAttribute("ry", "10");
                    aliceRect.setAttribute("fill", "#f0f8ff");
                    aliceRect.setAttribute("stroke", "#3498db");
                    aliceRect.setAttribute("stroke-width", "2");
                    svg.appendChild(aliceRect);
                    
                    // Etiqueta Alicia
                    const aliceText = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    aliceText.setAttribute("x", "450");
                    aliceText.setAttribute("y", "30");
                    aliceText.setAttribute("text-anchor", "middle");
                    aliceText.setAttribute("font-size", "16");
                    aliceText.setAttribute("font-weight", "bold");
                    aliceText.textContent = "Alicia (Desencapsulador)";
                    svg.appendChild(aliceText);
                    
                    // Entradas
                    const skRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    skRect.setAttribute("x", "50");
                    skRect.setAttribute("y", "80");
                    skRect.setAttribute("width", "150");
                    skRect.setAttribute("height", "60");
                    skRect.setAttribute("rx", "5");
                    skRect.setAttribute("ry", "5");
                    skRect.setAttribute("fill", "#fef9e7");
                    skRect.setAttribute("stroke", "#f1c40f");
                    skRect.setAttribute("stroke-width", "2");
                    svg.appendChild(skRect);
                    
                    const skText = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    skText.setAttribute("x", "125");
                    skText.setAttribute("y", "115");
                    skText.setAttribute("text-anchor", "middle");
                    skText.setAttribute("font-size", "14");
                    skText.textContent = "Clave Privada (s, t, d)";
                    svg.appendChild(skText);
                    
                    const ctRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    ctRect.setAttribute("x", "50");
                    ctRect.setAttribute("y", "170");
                    ctRect.setAttribute("width", "150");
                    ctRect.setAttribute("height", "60");
                    ctRect.setAttribute("rx", "5");
                    ctRect.setAttribute("ry", "5");
                    ctRect.setAttribute("fill", "#f8f5ee");
                    ctRect.setAttribute("stroke", "#e67e22");
                    ctRect.setAttribute("stroke-width", "2");
                    svg.appendChild(ctRect);
                    
                    const ctText = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    ctText.setAttribute("x", "125");
                    ctText.setAttribute("y", "205");
                    ctText.setAttribute("text-anchor", "middle");
                    ctText.setAttribute("font-size", "14");
                    ctText.textContent = "Cifrado (u, v)";
                    svg.appendChild(ctText);
                    
                    // Pasos internos
                    const steps = [
                        "1. Calcular m' = v - s^T¬∑u",
                        "2. Recalcular cifrado",
                        "3. Verificar consistencia",
                        "4. Derivar clave K"
                    ];
                    
                    for (let i = 0; i < steps.length; i++) {
                        const stepText = document.createElementNS("http://www.w3.org/2000/svg", "text");
                        stepText.setAttribute("x", "360");
                        stepText.setAttribute("y", "80" + i * 30);
                        stepText.setAttribute("font-size", "14");
                        stepText.textContent = steps[i];
                        svg.appendChild(stepText);
                    }
                    
                    // Resultado
                    const keyRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    keyRect.setAttribute("x", "650");
                    keyRect.setAttribute("y", "120");
                    keyRect.setAttribute("width", "150");
                    keyRect.setAttribute("height", "60");
                    keyRect.setAttribute("rx", "5");
                    keyRect.setAttribute("ry", "5");
                    keyRect.setAttribute("fill", "#ebf5fb");
                    keyRect.setAttribute("stroke", "#3498db");
                    keyRect.setAttribute("stroke-width", "2");
                    svg.appendChild(keyRect);
                    
                    const keyText = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    keyText.setAttribute("x", "725");
                    keyText.setAttribute("y", "155");
                    keyText.setAttribute("text-anchor", "middle");
                    keyText.setAttribute("font-size", "14");
                    keyText.textContent = "Clave Compartida K";
                    svg.appendChild(keyText);
                    
                    // Flechas
                    const arrow1 = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    arrow1.setAttribute("x1", "200");
                    arrow1.setAttribute("y1", "110");
                    arrow1.setAttribute("x2", "350");
                    arrow1.setAttribute("y2", "110");
                    arrow1.setAttribute("stroke", "#3498db");
                    arrow1.setAttribute("stroke-width", "2");
                    arrow1.setAttribute("marker-end", "url(#arrowhead)");
                    svg.appendChild(arrow1);
                    
                    const arrow2 = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    arrow2.setAttribute("x1", "200");
                    arrow2.setAttribute("y1", "200");
                    arrow2.setAttribute("x2", "350");
                    arrow2.setAttribute("y2", "200");
                    arrow2.setAttribute("stroke", "#3498db");
                    arrow2.setAttribute("stroke-width", "2");
                    arrow2.setAttribute("marker-end", "url(#arrowhead)");
                    svg.appendChild(arrow2);
                    
                    const arrow3 = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    arrow3.setAttribute("x1", "550");
                    arrow3.setAttribute("y1", "150");
                    arrow3.setAttribute("x2", "650");
                    arrow3.setAttribute("y2", "150");
                    arrow3.setAttribute("stroke", "#3498db");
                    arrow3.setAttribute("stroke-width", "2");
                    arrow3.setAttribute("marker-end", "url(#arrowhead)");
                    svg.appendChild(arrow3);
                }
                
                // Definir marcador de flecha
                const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
                const marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
                marker.setAttribute("id", "arrowhead");
                marker.setAttribute("markerWidth", "10");
                marker.setAttribute("markerHeight", "7");
                marker.setAttribute("refX", "10");
                marker.setAttribute("refY", "3.5");
                marker.setAttribute("orient", "auto");
                
                const polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
                polygon.setAttribute("points", "0 0, 10 3.5, 0 7");
                polygon.setAttribute("fill", "#3498db");
                
                marker.appendChild(polygon);
                defs.appendChild(marker);
                svg.appendChild(defs);
                
                visualization.appendChild(title);
                visualization.appendChild(svg);
                
                // Leyenda
                const legend = document.createElement("div");
                legend.className = "visualization-legend";
                
                if (stage === 'keygen') {
                    legend.innerHTML = `
                        <p>El diagrama muestra el proceso de generaci√≥n de claves en ML-KEM-${level}.</p>
                        <p>Alicia genera un par de claves p√∫blica/privada que se utilizar√° para el intercambio seguro de claves.</p>
                    `;
                } else if (stage === 'encaps') {
                    legend.innerHTML = `
                        <p>El diagrama muestra el proceso de encapsulamiento en ML-KEM-${level}.</p>
                        <p>Bob utiliza la clave p√∫blica de Alicia para encapsular una clave compartida secreta.</p>
                    `;
                } else if (stage === 'decaps') {
                    legend.innerHTML = `
                        <p>El diagrama muestra el proceso de desencapsulamiento en ML-KEM-${level}.</p>
                        <p>Alicia utiliza su clave privada para recuperar la misma clave compartida secreta.</p>
                    `;
                }
                
                visualization.appendChild(legend);
            }
            
            // Manejador para el bot√≥n de generaci√≥n de claves
            btnGenerateKeys.addEventListener('click', function() {
                const level = securityLevel.value;
                
                // Simular generaci√≥n de claves
                const keys = simulateKeyGen(level);
                currentPublicKey = keys.publicKey;
                currentPrivateKey = keys.privateKey;
                
                // Mostrar informaci√≥n
                outputPasos.innerHTML = `
                    <p>Generando par de claves ML-KEM-${level}...</p>
                    <p>1. Generamos una semilla aleatoria d.</p>
                    <p>2. Derivamos la matriz A a partir de d.</p>
                    <p>3. Muestreamos el vector secreto s y el vector de error e.</p>
                    <p>4. Calculamos t = A¬∑s + e.</p>
                    <p>5. La clave p√∫blica es (t, d) y la clave privada es (s, t, d).</p>
                `;
                
                // Mostrar claves
                publicKey.textContent = `Tama√±o: ${currentPublicKey.size} bytes\nt: [${currentPublicKey.t[0].substring(0, 20)}...]\nd: ${currentPublicKey.d.substring(0, 20)}...`;
                privateKey.textContent = `Tama√±o: ${currentPrivateKey.size} bytes\ns: [${currentPrivateKey.s[0].substring(0, 20)}...]\nt: [${currentPrivateKey.t[0].substring(0, 20)}...]\nd: ${currentPrivateKey.d.substring(0, 20)}...`;
                
                // Visualizar
                visualizeMLKEM('keygen', level);
                
                // Habilitar bot√≥n de encapsulamiento
                btnEncaps.disabled = false;
                btnDecaps.disabled = true;
                
                // Reiniciar otros campos
                sharedKey.textContent = '-';
                ciphertext.textContent = '-';
            });
            
            // Manejador para el bot√≥n de encapsulamiento
            btnEncaps.addEventListener('click', function() {
                if (!currentPublicKey) {
                    alert("Primero debe generar un par de claves.");
                    return;
                }
                
                const level = securityLevel.value;
                
                // Simular encapsulamiento
                const result = simulateEncaps(currentPublicKey, level);
                currentCiphertext = result.ciphertext;
                currentSharedKey = result.sharedKey;
                
                // Mostrar informaci√≥n
                outputPasos.innerHTML = `
                    <p>Encapsulando clave compartida con ML-KEM-${level}...</p>
                    <p>1. Generamos un mensaje aleatorio m.</p>
                    <p>2. Derivamos una semilla a partir de m y d.</p>
                    <p>3. Muestreamos el vector r y los vectores de error e1 y e2.</p>
                    <p>4. Calculamos u = A^T¬∑r + e1.</p>
                    <p>5. Calculamos v = t^T¬∑r + e2 + ‚åàq/2‚åã¬∑m.</p>
                    <p>6. Comprimimos u y v para formar el cifrado.</p>
                    <p>7. Derivamos la clave compartida K a partir de m y el cifrado.</p>
                `;
                
                // Mostrar cifrado y clave compartida
                ciphertext.textContent = `Tama√±o: ${currentCiphertext.size} bytes\nu: [${currentCiphertext.u[0].substring(0, 20)}...]\nv: ${currentCiphertext.v.substring(0, 20)}...`;
                sharedKey.textContent = currentSharedKey;
                
                // Visualizar
                visualizeMLKEM('encaps', level);
                
                // Habilitar bot√≥n de desencapsulamiento
                btnDecaps.disabled = false;
            });
            
            // Manejador para el bot√≥n de desencapsulamiento
            btnDecaps.addEventListener('click', function() {
                if (!currentPrivateKey || !currentCiphertext) {
                    alert("Primero debe generar claves y encapsular una clave compartida.");
                    return;
                }
                
                const level = securityLevel.value;
                
                // Simular desencapsulamiento
                const decapsKey = simulateDecaps(currentPrivateKey, currentCiphertext);
                
                // Mostrar informaci√≥n
                outputPasos.innerHTML = `
                    <p>Desencapsulando clave compartida con ML-KEM-${level}...</p>
                    <p>1. Descomprimimos u y v del cifrado.</p>
                    <p>2. Calculamos m' = v - s^T¬∑u.</p>
                    <p>3. Decodificamos m' para obtener el mensaje m.</p>
                    <p>4. Recalculamos el cifrado para verificar su validez.</p>
                    <p>5. Derivamos la clave compartida K a partir de m y el cifrado.</p>
                    <p>6. ¬°√âxito! La clave compartida coincide con la generada durante el encapsulamiento.</p>
                `;
                
                // Visualizar
                visualizeMLKEM('decaps', level);
                
                // Mostrar mensaje de √©xito
                const successMessage = document.createElement("div");
                successMessage.className = "success-message";
                successMessage.innerHTML = `
                    <p><strong>¬°Intercambio de claves completado con √©xito!</strong></p>
                    <p>Alicia y Bob ahora comparten la misma clave secreta que pueden utilizar para cifrado sim√©trico.</p>
                `;
                outputPasos.appendChild(successMessage);
            });
            
            // Manejador para el bot√≥n de reinicio
            btnReset.addEventListener('click', function() {
                // Reiniciar estado
                currentPublicKey = null;
                currentPrivateKey = null;
                currentCiphertext = null;
                currentSharedKey = null;
                
                // Reiniciar interfaz
                securityLevel.value = "768";
                outputPasos.innerHTML = "<p>Seleccione un nivel de seguridad y haga clic en \"Generar Claves\" para comenzar.</p>";
                publicKey.textContent = "-";
                privateKey.textContent = "-";
                sharedKey.textContent = "-";
                ciphertext.textContent = "-";
                visualization.innerHTML = "";
                
                // Deshabilitar botones
                btnEncaps.disabled = true;
                btnDecaps.disabled = true;
            });
        });
    </script>
</body>
</html>
