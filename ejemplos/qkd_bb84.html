<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QKD (BB84) - Ejemplos Pr√°cticos - Curso de Criptograf√≠a Post-Cu√°ntica</title>
    <link rel="stylesheet" href="../css/styles.css">
    <link rel="stylesheet" href="../css/prism.css">
</head>
<body>
    <header>
        <h1>Curso de Criptograf√≠a Post-Cu√°ntica</h1>
        <p>Un enfoque introductorio a la seguridad en la era cu√°ntica</p>
        <div class="search-container">
            <input type="text" id="searchInput" placeholder="Buscar en el curso...">
            <button onclick="search()">üîç</button>
        </div>
        <nav>
            <ul>
                <li><a href="../index.html">Inicio</a></li>
                <li><a href="../programa.html">Programa</a></li>
                <li><a href="../temas/tema1/index.html">Temas</a></li>
                <li><a href="index.html">Ejemplos Pr√°cticos</a></li>
                <li><a href="../guias/index.html">Gu√≠as de Laboratorio</a></li>
                <li><a href="../recursos/index.html">Recursos</a></li>
            </ul>
        </nav>
    </header>

    <div class="breadcrumbs">
        <a href="../index.html">Inicio</a> &gt; <a href="index.html">Ejemplos Pr√°cticos</a> &gt; QKD (BB84)
    </div>

    <main>
        <h1>Distribuci√≥n Cu√°ntica de Claves: Protocolo BB84</h1>
        
        <section class="intro">
            <p>La Distribuci√≥n Cu√°ntica de Claves (QKD, por sus siglas en ingl√©s) es un m√©todo para compartir claves criptogr√°ficas que utiliza principios de la mec√°nica cu√°ntica para garantizar la seguridad. A diferencia de la criptograf√≠a post-cu√°ntica, que utiliza matem√°ticas cl√°sicas resistentes a ataques cu√°nticos, QKD aprovecha las propiedades fundamentales de la f√≠sica cu√°ntica.</p>
            <p>El protocolo BB84, propuesto por Bennett y Brassard en 1984, fue el primer protocolo QKD y sigue siendo uno de los m√°s importantes. En este ejemplo, exploraremos c√≥mo funciona BB84 y veremos una implementaci√≥n simplificada que ilustra sus principios fundamentales.</p>
        </section>

        <section class="example-code">
            <h2>Implementaci√≥n Simplificada del Protocolo BB84</h2>
            <p>El siguiente c√≥digo es una implementaci√≥n did√°ctica simplificada del protocolo BB84. No es una implementaci√≥n real de QKD (que requerir√≠a hardware cu√°ntico), sino una simulaci√≥n para ilustrar los conceptos.</p>
            
            <pre><code class="language-python">"""
Simulaci√≥n did√°ctica del protocolo BB84 para Distribuci√≥n Cu√°ntica de Claves
NOTA: Esta implementaci√≥n es solo para fines educativos y simula los efectos cu√°nticos.
"""
import numpy as np
import random
import hashlib
from enum import Enum

class Basis(Enum):
    RECTILINEAR = 0  # Base + (horizontal/vertical)
    DIAGONAL = 1     # Base √ó (diagonal)

class Qubit:
    def __init__(self, bit_value, basis):
        """
        Inicializa un qubit con un valor de bit y una base de medici√≥n
        
        Args:
            bit_value (int): 0 o 1
            basis (Basis): Base de preparaci√≥n (RECTILINEAR o DIAGONAL)
        """
        self.bit_value = bit_value
        self.basis = basis
    
    def measure(self, measurement_basis):
        """
        Mide el qubit en la base especificada
        
        Args:
            measurement_basis (Basis): Base de medici√≥n
            
        Returns:
            int: Resultado de la medici√≥n (0 o 1)
        """
        if measurement_basis == self.basis:
            # Si medimos en la misma base, obtenemos el valor original
            return self.bit_value
        else:
            # Si medimos en una base diferente, obtenemos un resultado aleatorio
            return random.randint(0, 1)
    
    def __str__(self):
        basis_symbol = "+" if self.basis == Basis.RECTILINEAR else "√ó"
        return f"{self.bit_value}{basis_symbol}"

class QuantumChannel:
    def __init__(self, error_rate=0.0, eve_present=False):
        """
        Inicializa un canal cu√°ntico con una tasa de error y presencia de esp√≠a
        
        Args:
            error_rate (float): Tasa de error del canal (0.0 a 1.0)
            eve_present (bool): Si hay un esp√≠a (Eve) en el canal
        """
        self.error_rate = error_rate
        self.eve_present = eve_present
        self.eve_bases = []  # Bases que Eve usar√° para medir
    
    def transmit(self, qubits):
        """
        Transmite qubits a trav√©s del canal
        
        Args:
            qubits (list): Lista de objetos Qubit
            
        Returns:
            list: Lista de qubits potencialmente alterados
        """
        transmitted_qubits = []
        
        # Si Eve est√° presente, genera bases aleatorias para medir
        if self.eve_present:
            self.eve_bases = [random.choice(list(Basis)) for _ in range(len(qubits))]
            self.eve_measurements = []
        
        for i, qubit in enumerate(qubits):
            # Copia del qubit original
            transmitted = Qubit(qubit.bit_value, qubit.basis)
            
            # Si Eve est√° presente, intercepta y mide el qubit
            if self.eve_present:
                eve_measurement = qubit.measure(self.eve_bases[i])
                self.eve_measurements.append(eve_measurement)
                
                # Eve reenv√≠a un nuevo qubit basado en su medici√≥n
                transmitted = Qubit(eve_measurement, self.eve_bases[i])
            
            # Simular errores del canal
            if random.random() < self.error_rate:
                # Invertir el bit con probabilidad error_rate
                transmitted.bit_value = 1 - transmitted.bit_value
            
            transmitted_qubits.append(transmitted)
        
        return transmitted_qubits

class BB84Protocol:
    def __init__(self, num_bits=1000, error_rate=0.0, eve_present=False):
        """
        Inicializa el protocolo BB84
        
        Args:
            num_bits (int): N√∫mero de bits a transmitir
            error_rate (float): Tasa de error del canal
            eve_present (bool): Si hay un esp√≠a en el canal
        """
        self.num_bits = num_bits
        self.channel = QuantumChannel(error_rate, eve_present)
        
        # Datos de Alice
        self.alice_bits = []
        self.alice_bases = []
        
        # Datos de Bob
        self.bob_bases = []
        self.bob_measurements = []
        
        # Datos de Eve (si est√° presente)
        self.eve_bases = []
        self.eve_measurements = []
        
        # Resultados del protocolo
        self.matching_bases_indices = []
        self.sample_indices = []
        self.key_indices = []
        self.error_rate = 0.0
        self.final_key = []
    
    def alice_prepares_qubits(self):
        """Alice prepara qubits aleatorios en bases aleatorias"""
        self.alice_bits = [random.randint(0, 1) for _ in range(self.num_bits)]
        self.alice_bases = [random.choice(list(Basis)) for _ in range(self.num_bits)]
        
        qubits = [Qubit(self.alice_bits[i], self.alice_bases[i]) 
                 for i in range(self.num_bits)]
        
        return qubits
    
    def bob_measures_qubits(self, qubits):
        """Bob mide los qubits recibidos en bases aleatorias"""
        self.bob_bases = [random.choice(list(Basis)) for _ in range(len(qubits))]
        self.bob_measurements = [qubits[i].measure(self.bob_bases[i]) 
                               for i in range(len(qubits))]
    
    def compare_bases(self):
        """Alice y Bob comparan sus bases y descartan las no coincidentes"""
        self.matching_bases_indices = [i for i in range(self.num_bits) 
                                     if self.alice_bases[i] == self.bob_bases[i]]
        
        print(f"Bases coincidentes: {len(self.matching_bases_indices)}/{self.num_bits}")
    
    def estimate_error_rate(self, sample_size=100):
        """
        Alice y Bob estiman la tasa de error sacrificando algunos bits
        
        Args:
            sample_size (int): N√∫mero de bits a sacrificar para la estimaci√≥n
        """
        # Asegurarse de que no intentamos muestrear m√°s bits de los disponibles
        sample_size = min(sample_size, len(self.matching_bases_indices))
        
        # Seleccionar √≠ndices aleatorios para el muestreo
        self.sample_indices = random.sample(self.matching_bases_indices, sample_size)
        
        # Contar errores en los bits de muestra
        errors = sum(1 for i in self.sample_indices 
                    if self.alice_bits[i] != self.bob_measurements[i])
        
        self.error_rate = errors / sample_size
        
        print(f"Tasa de error estimada: {self.error_rate:.2%}")
        
        # Determinar si la tasa de error es aceptable (t√≠picamente < 11%)
        return self.error_rate < 0.11
    
    def generate_key(self):
        """Alice y Bob generan la clave final con los bits restantes"""
        # Excluir los bits usados para la estimaci√≥n de error
        self.key_indices = [i for i in self.matching_bases_indices 
                          if i not in self.sample_indices]
        
        # Extraer los bits para la clave final
        self.final_key = [self.alice_bits[i] for i in self.key_indices]
        
        # En una implementaci√≥n real, se aplicar√≠a:
        # 1. Reconciliaci√≥n de informaci√≥n (correcci√≥n de errores)
        # 2. Amplificaci√≥n de privacidad (hash)
        
        # Simulamos la amplificaci√≥n de privacidad con un hash simple
        key_string = ''.join(str(bit) for bit in self.final_key)
        hashed_key = hashlib.sha256(key_string.encode()).hexdigest()
        
        print(f"Longitud de la clave final: {len(self.final_key)} bits")
        print(f"Muestra de la clave: {''.join(str(bit) for bit in self.final_key[:16])}...")
        print(f"Clave hash: {hashed_key}")
        
        return self.final_key
    
    def run_protocol(self):
        """Ejecuta el protocolo BB84 completo"""
        print("=== Iniciando Protocolo BB84 ===")
        
        # Paso 1: Alice prepara qubits
        print("\nPaso 1: Alice prepara qubits")
        qubits = self.alice_prepares_qubits()
        
        # Paso 2: Alice env√≠a qubits a Bob a trav√©s del canal cu√°ntico
        print("\nPaso 2: Transmisi√≥n por canal cu√°ntico")
        received_qubits = self.channel.transmit(qubits)
        
        # Si Eve est√° presente, guardamos sus datos
        if self.channel.eve_present:
            self.eve_bases = self.channel.eve_bases
            self.eve_measurements = self.channel.eve_measurements
        
        # Paso 3: Bob mide los qubits recibidos
        print("\nPaso 3: Bob mide los qubits recibidos")
        self.bob_measures_qubits(received_qubits)
        
        # Paso 4: Alice y Bob comparan bases
        print("\nPaso 4: Comparaci√≥n de bases")
        self.compare_bases()
        
        # Paso 5: Estimaci√≥n de la tasa de error
        print("\nPaso 5: Estimaci√≥n de la tasa de error")
        error_acceptable = self.estimate_error_rate()
        
        if not error_acceptable:
            print("\n‚ö†Ô∏è Tasa de error demasiado alta. Posible presencia de esp√≠a.")
            print("Protocolo abortado.")
            return None
        
        # Paso 6: Generaci√≥n de la clave final
        print("\nPaso 6: Generaci√≥n de la clave final")
        key = self.generate_key()
        
        print("\n=== Protocolo BB84 completado con √©xito ===")
        
        return key

# Ejemplo de uso
if __name__ == "__main__":
    # Ejecutar protocolo sin esp√≠a
    print("\n=== EJECUCI√ìN SIN ESP√çA ===")
    protocol = BB84Protocol(num_bits=1000, error_rate=0.05, eve_present=False)
    key_without_eve = protocol.run_protocol()
    
    # Ejecutar protocolo con esp√≠a
    print("\n\n=== EJECUCI√ìN CON ESP√çA ===")
    protocol_with_eve = BB84Protocol(num_bits=1000, error_rate=0.05, eve_present=True)
    key_with_eve = protocol_with_eve.run_protocol()
</code></pre>
        </section>

        <section class="explanation">
            <h2>Explicaci√≥n del Protocolo BB84</h2>
            
            <h3>Fundamentos Cu√°nticos</h3>
            <p>El protocolo BB84 se basa en dos principios fundamentales de la mec√°nica cu√°ntica:</p>
            <ol>
                <li><strong>Principio de incertidumbre de Heisenberg:</strong> No es posible medir simult√°neamente ciertas propiedades complementarias de un sistema cu√°ntico con precisi√≥n arbitraria.</li>
                <li><strong>Teorema de no clonaci√≥n:</strong> Es imposible crear una copia exacta de un estado cu√°ntico desconocido.</li>
            </ol>
            
            <p>Estos principios garantizan que cualquier intento de interceptar la comunicaci√≥n cu√°ntica alterar√° inevitablemente los estados, permitiendo detectar la presencia de un esp√≠a.</p>
            
            <h3>Pasos del Protocolo BB84</h3>
            <div class="protocol-steps">
                <div class="step">
                    <h4>Paso 1: Preparaci√≥n de Qubits</h4>
                    <p>Alice genera dos secuencias aleatorias:</p>
                    <ul>
                        <li>Una secuencia de bits (0s y 1s)</li>
                        <li>Una secuencia de bases (rectilinear + y diagonal √ó)</li>
                    </ul>
                    <p>Para cada bit, Alice prepara un qubit en la base correspondiente:</p>
                    <ul>
                        <li>Base rectilinear (+): |0‚ü© para bit 0, |1‚ü© para bit 1</li>
                        <li>Base diagonal (√ó): |+‚ü© para bit 0, |‚àí‚ü© para bit 1</li>
                    </ul>
                </div>
                
                <div class="step">
                    <h4>Paso 2: Transmisi√≥n Cu√°ntica</h4>
                    <p>Alice env√≠a los qubits a Bob a trav√©s de un canal cu√°ntico.</p>
                    <p>Si Eve intenta interceptar los qubits, debe elegir una base para medirlos:</p>
                    <ul>
                        <li>Si elige la misma base que Alice, obtiene el bit correcto pero altera el estado</li>
                        <li>Si elige una base diferente, obtiene un resultado aleatorio y altera el estado</li>
                    </ul>
                </div>
                
                <div class="step">
                    <h4>Paso 3: Medici√≥n de Qubits</h4>
                    <p>Bob genera una secuencia aleatoria de bases y mide cada qubit recibido en la base correspondiente.</p>
                    <p>Resultados de la medici√≥n:</p>
                    <ul>
                        <li>Si Bob usa la misma base que Alice, obtiene el bit original con alta probabilidad</li>
                        <li>Si Bob usa una base diferente, obtiene un resultado aleatorio (0 o 1 con igual probabilidad)</li>
                    </ul>
                </div>
                
                <div class="step">
                    <h4>Paso 4: Comparaci√≥n de Bases</h4>
                    <p>Alice y Bob revelan p√∫blicamente las bases que utilizaron (pero no los bits).</p>
                    <p>Descartan todos los bits donde usaron bases diferentes, conservando solo aquellos donde coincidieron las bases.</p>
                    <p>Aproximadamente el 50% de los bits se conservan en este paso.</p>
                </div>
                
                <div class="step">
                    <h4>Paso 5: Estimaci√≥n de Error</h4>
                    <p>Alice y Bob revelan p√∫blicamente una muestra aleatoria de sus bits coincidentes para estimar la tasa de error.</p>
                    <p>Si la tasa de error es mayor que un umbral (t√≠picamente 11%), sospechan la presencia de un esp√≠a y abortan el protocolo.</p>
                    <p>La presencia de Eve introduce errores porque:</p>
                    <ul>
                        <li>Eve elige la base incorrecta aproximadamente el 50% del tiempo</li>
                        <li>Cuando Eve elige la base incorrecta, introduce un error del 50%</li>
                        <li>Esto resulta en una tasa de error del 25% cuando Eve intercepta todos los qubits</li>
                    </ul>
                </div>
                
                <div class="step">
                    <h4>Paso 6: Procesamiento Final</h4>
                    <p>Si la tasa de error es aceptable, Alice y Bob:</p>
                    <ul>
                        <li>Realizan reconciliaci√≥n de informaci√≥n (correcci√≥n de errores)</li>
                        <li>Aplican amplificaci√≥n de privacidad (funciones hash) para eliminar cualquier informaci√≥n parcial que Eve pudiera haber obtenido</li>
                    </ul>
                    <p>El resultado es una clave secreta compartida que puede usarse para cifrado sim√©trico.</p>
                </div>
            </div>
        </section>

        <section class="comparison">
            <h2>QKD vs. Criptograf√≠a Post-Cu√°ntica</h2>
            <table>
                <thead>
                    <tr>
                        <th>Caracter√≠stica</th>
                        <th>Distribuci√≥n Cu√°ntica de Claves (QKD)</th>
                        <th>Criptograf√≠a Post-Cu√°ntica (PQC)</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Base de seguridad</td>
                        <td>Leyes de la f√≠sica cu√°ntica</td>
                        <td>Problemas matem√°ticos computacionalmente dif√≠ciles</td>
                    </tr>
                    <tr>
                        <td>Hardware requerido</td>
                        <td>Dispositivos cu√°nticos especializados</td>
                        <td>Hardware convencional</td>
                    </tr>
                    <tr>
                        <td>Distancia</td>
                        <td>Limitada (t√≠picamente <100 km sin repetidores)</td>
                        <td>Ilimitada</td>
                    </tr>
                    <tr>
                        <td>Tasa de transferencia</td>
                        <td>Baja (kbps o menos)</td>
                        <td>Alta (comparable a criptograf√≠a cl√°sica)</td>
                    </tr>
                    <tr>
                        <td>Infraestructura</td>
                        <td>Requiere canales cu√°nticos dedicados</td>
                        <td>Compatible con infraestructura existente</td>
                    </tr>
                    <tr>
                        <td>Aplicaci√≥n</td>
                        <td>Solo distribuci√≥n de claves</td>
                        <td>Cifrado, firmas, intercambio de claves</td>
                    </tr>
                    <tr>
                        <td>Madurez</td>
                        <td>Implementaciones comerciales limitadas</td>
                        <td>Est√°ndares emergentes (NIST)</td>
                    </tr>
                    <tr>
                        <td>Seguridad probada</td>
                        <td>Seguridad incondicional (te√≥ricamente)</td>
                        <td>Seguridad computacional (basada en supuestos)</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section class="applications">
            <h2>Aplicaciones Pr√°cticas de QKD</h2>
            <p>A pesar de sus limitaciones, QKD ya se est√° utilizando en varios contextos:</p>
            <ul>
                <li><strong>Redes financieras:</strong> Bancos y bolsas de valores para proteger transacciones de alta seguridad.</li>
                <li><strong>Infraestructuras cr√≠ticas:</strong> Protecci√≥n de comunicaciones en redes el√©ctricas, plantas nucleares y sistemas de control industrial.</li>
                <li><strong>Comunicaciones gubernamentales:</strong> Agencias de inteligencia y defensa para comunicaciones ultra-seguras.</li>
                <li><strong>Redes metropolitanas:</strong> Implementaciones en ciudades como Tokio, Viena, Boston y Pek√≠n.</li>
                <li><strong>Comunicaciones satelitales:</strong> China ha demostrado QKD v√≠a sat√©lite (Micius) a distancias de m√°s de 1,200 km.</li>
            </ul>
            
            <p>El futuro de QKD incluye el desarrollo de repetidores cu√°nticos y redes cu√°nticas que podr√≠an extender significativamente su alcance y aplicabilidad.</p>
        </section>

        <div class="interactive-demo">
            <h2>Demostraci√≥n Interactiva: Protocolo BB84</h2>
            <div class="demo-container">
                <div class="demo-controls">
                    <div class="control-group">
                        <label for="eve-checkbox">Incluir esp√≠a (Eve):</label>
                        <input type="checkbox" id="eve-checkbox">
                    </div>
                    <button id="start-qkd-btn">Iniciar Simulaci√≥n</button>
                    <button id="next-step-btn" disabled>Siguiente Paso</button>
                    <button id="reset-qkd-btn" disabled>Reiniciar</button>
                </div>
                <div class="demo-output">
                    <div class="output-section">
                        <h3>Estado</h3>
                        <div id="qkd-status-output" class="status-box">Esperando inicio de simulaci√≥n...</div>
                    </div>
                    <div class="output-section">
                        <h3>Alice</h3>
                        <div id="alice-display" class="participant-box"></div>
                    </div>
                    <div class="output-section">
                        <h3>Canal Cu√°ntico</h3>
                        <div id="quantum-channel-display" class="channel-box"></div>
                    </div>
                    <div class="output-section">
                        <h3>Bob</h3>
                        <div id="bob-display" class="participant-box"></div>
                    </div>
                    <div class="output-section">
                        <h3>Canal Cl√°sico</h3>
                        <div id="classical-channel-display" class="channel-box"></div>
                    </div>
                    <div class="output-section">
                        <h3>Clave Final</h3>
                        <div id="final-key-display" class="key-box"></div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <footer>
        <div class="footer-content">
            <div class="footer-section">
                <h3>Mapa del Sitio</h3>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="../programa.html">Programa</a></li>
                    <li><a href="../temas/tema1/index.html">Temas</a></li>
                    <li><a href="index.html">Ejemplos Pr√°cticos</a></li>
                    <li><a href="../guias/index.html">Gu√≠as de Laboratorio</a></li>
                    <li><a href="../recursos/index.html">Recursos</a></li>
                </ul>
            </div>
            <div class="footer-section">
                <h3>Ejemplos</h3>
                <ul>
                    <li><a href="algoritmo_shor.html">Algoritmo de Shor</a></li>
                    <li><a href="ml_kem.html">ML-KEM</a></li>
                    <li><a href="ml_dsa.html">ML-DSA</a></li>
                    <li><a href="criptografia_hibrida.html">Criptograf√≠a H√≠brida</a></li>
                    <li><a href="qkd_bb84.html">QKD (BB84)</a></li>
                </ul>
            </div>
            <div class="footer-section">
                <h3>Contacto</h3>
                <p>Para consultas sobre el curso, contacte al profesor.</p>
            </div>
        </div>
        <div class="footer-bottom">
            <p>&copy; 2025 Curso de Criptograf√≠a Post-Cu√°ntica</p>
        </div>
    </footer>

    <script src="../js/script.js"></script>
    <script src="../js/examples.js"></script>
    <script src="../js/qkd_bb84_interactive.js"></script>
</body>
</html>
