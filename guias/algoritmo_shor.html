<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algoritmo de Shor - Gu√≠a de Laboratorio</title>
    <link rel="stylesheet" href="../css/styles.css">
</head>
<body>
    <header>
        <h1>Curso de Criptograf√≠a Post-Cu√°ntica</h1>
        <p>Un enfoque introductorio a la seguridad en la era cu√°ntica</p>
        <div class="search-container">
            <input type="text" id="searchInput" placeholder="Buscar en el curso...">
            <button onclick="search()">üîç</button>
        </div>
        <nav>
            <ul>
                <li><a href="../index.html">Inicio</a></li>
                <li><a href="../programa.html">Programa</a></li>
                <li><a href="../temas/tema1/index.html">Temas</a></li>
                <li><a href="../ejemplos/index.html">Ejemplos Pr√°cticos</a></li>
                <li><a href="index.html">Gu√≠as de Laboratorio</a></li>
                <li><a href="../recursos/index.html">Recursos</a></li>
            </ul>
        </nav>
    </header>

    <div class="breadcrumbs">
        <a href="../index.html">Inicio</a> &gt; <a href="index.html">Gu√≠as de Laboratorio</a> &gt; Algoritmo de Shor
    </div>

    <main>
        <h1>Gu√≠a de Laboratorio: Simulaci√≥n del Algoritmo de Shor</h1>

        <section class="lab-section">
            <h2>Objetivos de Aprendizaje</h2>
            <ul>
                <li>Comprender los fundamentos te√≥ricos del algoritmo cu√°ntico de Shor</li>
                <li>Implementar una simulaci√≥n simplificada del algoritmo</li>
                <li>Analizar c√≥mo este algoritmo compromete la seguridad de RSA</li>
                <li>Evaluar las implicaciones para la criptograf√≠a actual</li>
            </ul>
        </section>

        <section class="lab-section">
            <h2>Requisitos Previos</h2>
            <ul>
                <li>Conocimientos b√°sicos de criptograf√≠a de clave p√∫blica (RSA)</li>
                <li>Familiaridad con conceptos matem√°ticos: teor√≠a de n√∫meros, aritm√©tica modular</li>
                <li>Python 3.8 o superior instalado</li>
                <li>Bibliotecas requeridas: numpy, matplotlib, qiskit (opcional para la parte avanzada)</li>
            </ul>

            <div class="alert alert-info">
                <p><strong>Nota:</strong> Esta pr√°ctica utiliza una simulaci√≥n cl√°sica del algoritmo de Shor. No se requiere un ordenador cu√°ntico real.</p>
            </div>
        </section>

        <section class="lab-section">
            <h2>Introducci√≥n Te√≥rica</h2>
            <p>El algoritmo de Shor, desarrollado por Peter Shor en 1994, es un algoritmo cu√°ntico que puede factorizar n√∫meros enteros en tiempo polin√≥mico. Su importancia radica en que puede romper eficientemente el cifrado RSA, que basa su seguridad en la dificultad de factorizar n√∫meros grandes.</p>
            
            <p>El algoritmo consta de dos partes principales:</p>
            <ol>
                <li><strong>Reducci√≥n del problema de factorizaci√≥n a encontrar el per√≠odo de una funci√≥n</strong>: Transformar el problema de factorizar N en encontrar el per√≠odo de la funci√≥n f(x) = a^x mod N, donde a es un n√∫mero coprimo con N.</li>
                <li><strong>Encontrar el per√≠odo utilizando la transformada cu√°ntica de Fourier</strong>: Utilizar un algoritmo cu√°ntico para encontrar el per√≠odo de la funci√≥n anterior de manera eficiente.</li>
            </ol>

            <p>Una vez encontrado el per√≠odo r, podemos calcular factores de N con alta probabilidad utilizando el m√°ximo com√∫n divisor (MCD) de N y a^(r/2) ¬± 1.</p>
        </section>

        <section class="lab-section">
            <h2>Parte 1: Implementaci√≥n Cl√°sica Simplificada</h2>
            
            <h3>1.1 Configuraci√≥n del Entorno</h3>
            <p>Crea un nuevo archivo Python llamado <code>shor_simulation.py</code> e importa las bibliotecas necesarias:</p>
            <pre><code class="language-python">import numpy as np
import math
import random
import matplotlib.pyplot as plt
from fractions import Fraction
</code></pre>

            <h3>1.2 Implementaci√≥n de Funciones Auxiliares</h3>
            <p>Primero, implementaremos algunas funciones auxiliares necesarias:</p>
            <pre><code class="language-python"># Calcular el m√°ximo com√∫n divisor (MCD)
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

# Exponenciaci√≥n modular r√°pida
def mod_exp(base, exponent, modulus):
    if modulus == 1:
        return 0
    result = 1
    base = base % modulus
    while exponent > 0:
        if exponent % 2 == 1:
            result = (result * base) % modulus
        exponent = exponent >> 1
        base = (base * base) % modulus
    return result

# Encontrar un n√∫mero aleatorio coprimo con n
def find_coprime(n):
    a = random.randint(2, n-1)
    while gcd(a, n) != 1:
        a = random.randint(2, n-1)
    return a

# Expansi√≥n de fracci√≥n continua para aproximar fracciones
def continued_fraction_expansion(x, y, max_denominator):
    fractions = []
    a = Fraction(x, y).limit_denominator(max_denominator)
    fractions.append(a)
    
    # Generar convergentes intermedios
    n, d = a.numerator, a.denominator
    for i in range(1, d):
        if i * a.denominator <= max_denominator:
            fractions.append(Fraction(round(i * a.numerator / a.denominator), i))
    
    return fractions
</code></pre>

            <h3>1.3 Implementaci√≥n del Algoritmo de Shor Cl√°sico</h3>
            <p>Ahora implementaremos una versi√≥n simplificada del algoritmo de Shor:</p>
            <pre><code class="language-python">def find_period_classically(a, N):
    """
    Encuentra el per√≠odo de f(x) = a^x mod N de manera cl√°sica (ineficiente).
    En un ordenador cu√°ntico real, esta parte ser√≠a mucho m√°s eficiente.
    """
    x = 1
    for r in range(1, N):
        x = (x * a) % N
        if x == 1:
            return r
    return None

def shor_algorithm_classical(N, max_attempts=5):
    """
    Implementaci√≥n cl√°sica simplificada del algoritmo de Shor
    """
    if N % 2 == 0:
        return 2, N // 2
    
    for _ in range(max_attempts):
        # Paso 1: Elegir un n√∫mero aleatorio a < N
        a = find_coprime(N)
        print(f"Intentando con a = {a}")
        
        # Paso 2: Encontrar el per√≠odo r (en un ordenador cu√°ntico, esto ser√≠a mucho m√°s r√°pido)
        r = find_period_classically(a, N)
        
        if r is None:
            print("No se encontr√≥ per√≠odo. Intentando con otro valor de a.")
            continue
            
        print(f"Per√≠odo encontrado: r = {r}")
        
        # Paso 3: Verificar condiciones
        if r % 2 != 0:
            print("El per√≠odo es impar. Intentando con otro valor de a.")
            continue
            
        x = mod_exp(a, r // 2, N)
        if x == N - 1:
            print("a^(r/2) ‚â° -1 (mod N). Intentando con otro valor de a.")
            continue
        
        # Paso 4: Calcular factores
        factor1 = gcd(x - 1, N)
        factor2 = gcd(x + 1, N)
        
        if factor1 > 1 and factor1 < N:
            return factor1, N // factor1
        if factor2 > 1 and factor2 < N:
            return factor2, N // factor2
    
    return None, None
</code></pre>

            <h3>1.4 Funci√≥n Principal y Visualizaci√≥n</h3>
            <p>Finalmente, implementaremos la funci√≥n principal y algunas visualizaciones:</p>
            <pre><code class="language-python">def main():
    # N√∫mero a factorizar (peque√±o para esta simulaci√≥n)
    N = 15  # = 3 √ó 5
    
    print(f"Intentando factorizar N = {N} usando el algoritmo de Shor (simulaci√≥n cl√°sica)")
    
    # Ejecutar el algoritmo
    factor1, factor2 = shor_algorithm_classical(N)
    
    if factor1 is not None:
        print(f"¬°Factorizaci√≥n exitosa! {N} = {factor1} √ó {factor2}")
        
        # Visualizaci√≥n
        plt.figure(figsize=(10, 6))
        
        # Gr√°fico de la funci√≥n f(x) = a^x mod N
        a = find_coprime(N)
        x_values = list(range(20))
        y_values = [mod_exp(a, x, N) for x in x_values]
        
        plt.subplot(1, 2, 1)
        plt.plot(x_values, y_values, 'o-')
        plt.title(f"Funci√≥n f(x) = {a}^x mod {N}")
        plt.xlabel("x")
        plt.ylabel(f"{a}^x mod {N}")
        plt.grid(True)
        
        # Histograma de valores
        plt.subplot(1, 2, 2)
        plt.hist(y_values, bins=range(min(y_values), max(y_values) + 2), alpha=0.7)
        plt.title(f"Distribuci√≥n de valores de {a}^x mod {N}")
        plt.xlabel("Valor")
        plt.ylabel("Frecuencia")
        plt.grid(True)
        
        plt.tight_layout()
        plt.savefig('shor_visualization.png')
        plt.show()
    else:
        print("No se pudo factorizar N con los intentos realizados.")

if __name__ == "__main__":
    main()
</code></pre>
        </section>

        <section class="lab-section">
            <h2>Parte 2: An√°lisis de Seguridad de RSA</h2>
            
            <h3>2.1 Implementaci√≥n Simplificada de RSA</h3>
            <p>Ahora implementaremos una versi√≥n simplificada de RSA para demostrar su vulnerabilidad:</p>
            <pre><code class="language-python"># Crear un nuevo archivo rsa_simulation.py
import random
from math import gcd

def is_prime(n, k=5):
    """Test de primalidad de Miller-Rabin simplificado"""
    if n <= 1 or n == 4:
        return False
    if n <= 3:
        return True
    
    # Implementaci√≥n simplificada para n√∫meros peque√±os
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def generate_prime(bits):
    """Genera un n√∫mero primo de aproximadamente 'bits' bits"""
    # Para esta simulaci√≥n, usamos primos peque√±os
    primes = [p for p in range(10, 100) if is_prime(p)]
    return random.choice(primes)

def mod_inverse(e, phi):
    """Calcula el inverso modular de e m√≥dulo phi"""
    def extended_gcd(a, b):
        if a == 0:
            return b, 0, 1
        else:
            gcd, x, y = extended_gcd(b % a, a)
            return gcd, y - (b // a) * x, x
    
    g, x, y = extended_gcd(e, phi)
    if g != 1:
        raise Exception('El inverso modular no existe')
    else:
        return x % phi

def generate_rsa_keys():
    """Genera un par de claves RSA (simplificado)"""
    # Generar dos primos distintos
    p = generate_prime(8)
    q = generate_prime(8)
    while p == q:
        q = generate_prime(8)
    
    n = p * q
    phi = (p - 1) * (q - 1)
    
    # Elegir e coprimo con phi
    e = random.randint(3, phi - 1)
    while gcd(e, phi) != 1:
        e = random.randint(3, phi - 1)
    
    # Calcular d (inverso modular de e m√≥dulo phi)
    d = mod_inverse(e, phi)
    
    return (e, n), (d, n), p, q

def rsa_encrypt(message, public_key):
    """Cifra un mensaje usando RSA"""
    e, n = public_key
    return pow(message, e, n)

def rsa_decrypt(ciphertext, private_key):
    """Descifra un mensaje usando RSA"""
    d, n = private_key
    return pow(ciphertext, d, n)

def main_rsa():
    # Generar claves
    public_key, private_key, p, q = generate_rsa_keys()
    e, n = public_key
    d, _ = private_key
    
    print(f"Generadas claves RSA con n = {n} = {p} √ó {q}")
    print(f"Clave p√∫blica: (e={e}, n={n})")
    print(f"Clave privada: (d={d}, n={n})")
    
    # Cifrar y descifrar un mensaje
    message = random.randint(2, n-1)
    print(f"Mensaje original: {message}")
    
    ciphertext = rsa_encrypt(message, public_key)
    print(f"Mensaje cifrado: {ciphertext}")
    
    decrypted = rsa_decrypt(ciphertext, private_key)
    print(f"Mensaje descifrado: {decrypted}")
    
    # Intentar romper RSA usando el algoritmo de Shor
    print("\nIntentando romper RSA usando el algoritmo de Shor...")
    from shor_simulation import shor_algorithm_classical
    
    factor1, factor2 = shor_algorithm_classical(n)
    
    if factor1 is not None:
        print(f"¬°RSA comprometido! Se han encontrado los factores: {factor1} y {factor2}")
        
        # Reconstruir la clave privada
        phi_recovered = (factor1 - 1) * (factor2 - 1)
        d_recovered = mod_inverse(e, phi_recovered)
        print(f"Clave privada recuperada: (d={d_recovered}, n={n})")
        
        # Verificar descifrando el mensaje
        decrypted_recovered = pow(ciphertext, d_recovered, n)
        print(f"Mensaje descifrado con la clave recuperada: {decrypted_recovered}")
        print(f"¬øCoincide con el mensaje original? {'S√≠' if decrypted_recovered == message else 'No'}")
    else:
        print("No se pudo factorizar n con los intentos realizados.")

if __name__ == "__main__":
    main_rsa()
</code></pre>
        </section>

        <section class="lab-section">
            <h2>Parte 3: Ejercicios y Preguntas de Reflexi√≥n</h2>
            
            <h3>3.1 Ejercicios</h3>
            <ol>
                <li>Modifica el c√≥digo para factorizar otros n√∫meros compuestos peque√±os (por ejemplo, 21, 33, 35).</li>
                <li>Implementa una funci√≥n que calcule el tiempo que tardar√≠a un ordenador cl√°sico en factorizar n√∫meros de diferentes tama√±os usando el algoritmo de fuerza bruta.</li>
                <li>Compara la complejidad te√≥rica del algoritmo de Shor (O(log¬≥ N)) con la del mejor algoritmo cl√°sico conocido (aproximadamente O(e^(log N)^(1/3) * (log log N)^(2/3))).</li>
                <li>Modifica el c√≥digo RSA para usar n√∫meros primos m√°s grandes (dentro de lo razonable para una simulaci√≥n) y analiza c√≥mo afecta esto al tiempo de ejecuci√≥n del algoritmo de Shor cl√°sico.</li>
            </ol>
            
            <h3>3.2 Preguntas de Reflexi√≥n</h3>
            <ol>
                <li>¬øPor qu√© el algoritmo de Shor representa una amenaza tan significativa para RSA?</li>
                <li>¬øQu√© tama√±o de clave RSA se considera seguro actualmente contra ordenadores cl√°sicos? ¬øY contra ordenadores cu√°nticos potenciales?</li>
                <li>¬øQu√© otros algoritmos criptogr√°ficos, adem√°s de RSA, son vulnerables al algoritmo de Shor?</li>
                <li>¬øCu√°les son las limitaciones actuales para implementar el algoritmo de Shor en ordenadores cu√°nticos reales?</li>
                <li>¬øQu√© estrategias de migraci√≥n recomendar√≠as a una organizaci√≥n que actualmente utiliza RSA para proteger informaci√≥n sensible a largo plazo?</li>
            </ol>
        </section>

        <section class="lab-section">
            <h2>Parte 4: Extensi√≥n (Opcional) - Simulaci√≥n Cu√°ntica</h2>
            <p>Si tienes experiencia con bibliotecas de computaci√≥n cu√°ntica como Qiskit, puedes intentar implementar una simulaci√≥n m√°s realista del algoritmo de Shor:</p>
            <pre><code class="language-python"># Requiere: pip install qiskit
from qiskit import QuantumCircuit, Aer, execute
from qiskit.visualization import plot_histogram
import numpy as np
import matplotlib.pyplot as plt

# Esta es una implementaci√≥n muy simplificada y parcial
# Para una implementaci√≥n completa, consulta la documentaci√≥n de Qiskit

def qft_rotations(circuit, n):
    """Rotaciones QFT sin swaps"""
    if n == 0:
        return circuit
    n -= 1
    circuit.h(n)
    for qubit in range(n):
        circuit.cp(np.pi/2**(n-qubit), qubit, n)
    qft_rotations(circuit, n)

def qft(circuit, n):
    """Transformada cu√°ntica de Fourier"""
    qft_rotations(circuit, n)
    # Swaps
    for qubit in range(n//2):
        circuit.swap(qubit, n-qubit-1)
    return circuit

def inverse_qft(circuit, n):
    """QFT inversa"""
    # Swaps
    for qubit in range(n//2):
        circuit.swap(qubit, n-qubit-1)
    # Rotaciones inversas
    for j in range(n):
        for m in range(j):
            circuit.cp(-np.pi/2**(j-m), m, j)
        circuit.h(j)
    return circuit

def shor_period_finding_circuit(a, N, n_count, n_target):
    """Circuito para encontrar el per√≠odo en el algoritmo de Shor"""
    # Crear circuito
    circuit = QuantumCircuit(n_count + n_target, n_count)
    
    # Inicializar registros
    for q in range(n_count):
        circuit.h(q)
    circuit.x(n_count)
    
    # Aplicar operaciones U controladas
    # (Esta es una simplificaci√≥n extrema)
    for q in range(n_count):
        # Aplicar a^(2^q) mod N controlado por q
        # En una implementaci√≥n real, esto ser√≠a mucho m√°s complejo
        circuit.cp(2*np.pi*a**(2**q) % N / N, q, n_count)
    
    # Aplicar QFT inversa
    inverse_qft(circuit, n_count)
    
    # Medir
    circuit.measure(range(n_count), range(n_count))
    
    return circuit

def simulate_shor_quantum(a, N):
    """Simula la parte cu√°ntica del algoritmo de Shor"""
    # Par√°metros
    n_count = 8  # N√∫mero de qubits para el registro de conteo
    n_target = 4  # N√∫mero de qubits para el registro objetivo
    
    # Crear circuito
    circuit = shor_period_finding_circuit(a, N, n_count, n_target)
    
    # Simular
    simulator = Aer.get_backend('qasm_simulator')
    result = execute(circuit, simulator, shots=1024).result()
    counts = result.get_counts()
    
    # Visualizar
    plot_histogram(counts)
    plt.title(f"Distribuci√≥n de mediciones para a={a}, N={N}")
    plt.savefig('shor_quantum_simulation.png')
    plt.show()
    
    return counts

# Ejemplo de uso
# simulate_shor_quantum(7, 15)
</code></pre>
            <p>Esta implementaci√≥n es muy simplificada y no funcionar√° correctamente para el algoritmo de Shor completo, pero proporciona una idea de c√≥mo se podr√≠a abordar usando Qiskit.</p>
        </section>

        <section class="lab-section">
            <h2>Entregables</h2>
            <p>Al finalizar esta pr√°ctica, deber√°s entregar:</p>
            <ol>
                <li>C√≥digo fuente de las implementaciones (<code>shor_simulation.py</code> y <code>rsa_simulation.py</code>)</li>
                <li>Capturas de pantalla o gr√°ficos generados durante la ejecuci√≥n</li>
                <li>Un informe breve (m√°ximo 2 p√°ginas) que incluya:
                    <ul>
                        <li>Resultados obtenidos en las factorizaciones</li>
                        <li>Respuestas a las preguntas de reflexi√≥n</li>
                        <li>An√°lisis de la vulnerabilidad de RSA frente al algoritmo de Shor</li>
                        <li>Conclusiones sobre las implicaciones para la seguridad criptogr√°fica actual</li>
                    </ul>
                </li>
            </ol>
        </section>

        <section class="lab-section">
            <h2>Recursos Adicionales</h2>
            <ul>
                <li><a href="https://arxiv.org/abs/quant-ph/9508027" target="_blank">Art√≠culo original de Peter Shor</a></li>
                <li><a href="https://qiskit.org/textbook/ch-algorithms/shor.html" target="_blank">Tutorial de Qiskit sobre el algoritmo de Shor</a></li>
                <li><a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)" target="_blank">Wikipedia: RSA Cryptosystem</a></li>
                <li><a href="https://en.wikipedia.org/wiki/Shor%27s_algorithm" target="_blank">Wikipedia: Algoritmo de Shor</a></li>
            </ul>
        </section>
    </main>

    <footer>
        <div class="footer-content">
            <div class="footer-section">
                <h3>Mapa del Sitio</h3>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="../programa.html">Programa</a></li>
                    <li><a href="../temas/tema1/index.html">Temas</a></li>
                    <li><a href="../ejemplos/index.html">Ejemplos Pr√°cticos</a></li>
                    <li><a href="index.html">Gu√≠as de Laboratorio</a></li>
                    <li><a href="../recursos/index.html">Recursos</a></li>
                </ul>
            </div>
            <div class="footer-section">
                <h3>Gu√≠as Disponibles</h3>
                <ul>
                    <li><a href="algoritmo_shor.html">Algoritmo de Shor</a></li>
                    <li><a href="ml_kem.html">ML-KEM</a></li>
                    <li><a href="ml_dsa.html">ML-DSA</a></li>
                    <li><a href="criptografia_hibrida.html">Criptograf√≠a H√≠brida</a></li>
                    <li><a href="qkd.html">QKD (BB84)</a></li>
                </ul>
            </div>
            <div class="footer-section">
                <h3>Contacto</h3>
                <p>Para consultas sobre el curso, contacte al profesor.</p>
            </div>
        </div>
        <div class="footer-bottom">
            <p>&copy; 2025 Curso de Criptograf√≠a Post-Cu√°ntica</p>
        </div>
    </footer>

    <script src="../js/script.js"></script>
    <script src="../js/navigation.js"></script>
</body>
</html>
